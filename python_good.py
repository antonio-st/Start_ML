type()  # тип переменной
input()  # ввод строки

# базовые операции
5 * 2
6 / 2
5 // 2  # деление нацело
5 % 2  # остаток от деления
9 ** 0.5  # конень квадратный

# ----------------------------

# Порядок вычисления булевых операторов
# операторы and, or, not

1. Скобки
2. not
3. and
4. or

5 >= 1  # больше, либо равно
1 <= 5  # меньше либо равно
10 != 20  # не равно
'el' != 'Anton'

# ---------------------------------------------------------------------

# Списки
my_list = [1, 2, 3, 5, 9, 12]

# len оператор возвращающий длину(списка)
len(my_list)

# сложение списков
new_list = my_list + ['a', 'b', 'c', 'd']

# добавление в конец списка
new_list.append('g')

# удалить и вывести элемент
print(new_list.pop())  # удалить последний элемент
print(new_list.pop(1))  # удалить 2 элемент списка

# удаление по символу
print(new_list)
new_list.remove('a')  # удалить символ a
new_list.remove(12)  # удалить число 12

# ----------------------------------------------------------------------
# Кортеж / Tuple


# можно складывать
my_tuple + (5, 6)

# создать кортеж с 1 элементом
new_tuple = (1,)

my_tuple[2]  # 3 элемент кортежа

# ----------------------------------------------------------------------

# Set / Множества
a = {2, 'a', 3.14}  # создание множества с элементами
b = set()  # создание пустого множества

a.add(3)  # добавить элемент в множество
a.remove(3.14)  # удалить элемент 3.14

''''
в set можно добавлять только неизменяемые объекты

+ пересечение множеств `a.intersection(b)`
+ объединение `a.union(b)`
+ симметрическую разность `a.symmetric_difference`

''''

a = {'a', (1, 2), 3}
b = {3, (1, 2), 'union'}

a.intersection(b)  # те элементы которые пересекаются
a.union(b)  # общие уникальные элементы обоих множеств
a.symmetric_difference(b)  # не пересекающиеся элементы множества

# вычитание множеств
print(a - b)  # те элементы которые есть в a, но их нет в b # {'a'}
print(b - a)  # те элементы которые есть в b, но их нет в a # {'union'}


# ----------------------------------------------------------------------
# Словари / dict
# ключ: значение
name_to_number = {
    'Антон': '9187592724',
    'Никита': '495123456'
}
print(name_to_number)

# получаем значение по ключу
name_to_number['Антон']

# безопасное получение данных по ключу (например , если такого элемента нет)
print(name_to_number.get('Никита'))
print(name_to_number.get('Ники'))  # ключ не найден, выводим 'None'

# можно вывести определенный текст, если элемент не найден
print(name_to_number.get('Мария', 'not found'))

# добавление по ключу
name_to_number['Владимир'] = '+7 8685 100'


# используем оператор in ,чтобы проверить есть ли такой ключ
print('Владимир' in name_to_number)

# редактирование элемента словаря по ключу
name_to_number['Никита'] = '+7812123456'


# ----------------------------------------------------------------------
# Условия и циклы

# цикл for

for a in [9, 16, 25, 36, 49]:
    print('считаем в цикле for')
    print(a ** 0.5 + 1)  # корень из элемента a + 1
print('Пишем после цикла')

# range  - генерирует числа от 0 до n-1 (start, stop, step)
print(*range(0, 11))
# ----------
print('генерируем четные числа')
even_numbers = []
# -------------
for i in range(0, 20, 2):
    even_numbers.append(i)
print(even_numbers)
# -------------

# f-string - возможность подстановки выражения в строку
for i in range(1, 11):
    print(f'Квадрат {i} = {i * i} ')

# ----------------------------------------------------------------------
# Цикл WHILE
# работает до тех пор, пока верно утверждение

print('Считаем, сколько раз число делится на 2')
number = 34624
while number % 2 == 0:  # пока условие истинно - выполняется цикл
    print(f'{number} делиться на 2')
    number //= 2  # действие для выхода из цикла , равнозначно number = number // 2
print(number)


# ----------------------------------------------------------------------
# `Условный оператор IF`
# выполняем код в зависимости от условия

number = 4
if number % 2 == 0:
    print('Число четное')
else:
    print('Число нечетное')

# elif (else if)


if name == 'Москва':
    print('Столица России')
elif name == 'Минск':
    print('Столица Белоруссии')
elif name == 'Белград':
    print('Столица Сербии')
else:
    print('Нет в БД')


# ----------------------------------------------------------------------
# `Ключевые слова break, continue`
# Дополнения к for и while: это команды break и continue.
# Оба дают возможность выйти из цикла раньше задуманного.

# break

words = ['see', 'this', 'long', 'sentence', 'here', 'no-show', 'no-show']

for i in range(len(words)):
    print(words[i])
    if i > 2:  # на третьем слове выходим из цикла по break
        break
    # вывод see this long sentence


# в случае вложенного цикла break выходит только из внетреннего

for i in range(5):
    for j in range(7):
        print(i, j)
        if j > 2:
            break
    print('Увеличиваем i')

# continue

# выводит не из всего цикла, а пропускает одну иттерацию

for future in ['make sandwitch', 'make coffee', 'watch TV', 'wash plate']:
    if future == 'make coffee':
        # пропустить 1 иттерацию в цикле
        print('Coffee mashine is broken, skipping :(')
        continue
        # если условие истинно, но continue гарантирует, что дальше цикл выполняться не будет.
    print(f'starting action: {future}')


# ----------------------------------------------------------------------
# ФУНКЦИИ
def say_hello(name):
    print(f'Hello, {name}')

# return

# определить четное число или нет


def is_even(number):
    if number % 2 == 0:
        return True
    else:
        return False

# Аргументы по-умолчанию


def official_greeting(first_name='уважаемый', middle_name='клиент'):
    print(f'Здравствуйте, {first_name} {middle_name}!')


# call stack
# внутренняя функция
def inner_func(m):
    print('Считаем a')
    a = m // 2
    a = a * a
    print(f'возвращаем a = {a} во внешнюю функцию и возвращаемся')
    return a

# внешняя функция


def outer_func(num):
    num += 2
    print(num)
    print('выходим во внутреннюю функцию, внешняя останавливается')
    k = inner_func(num)
    print('Печатаем k и num')
    print(f'k = {k}, num = {num}')


# ----------------------------------------------------------------------
# Ошибки в Python

a = [1, 0, 2]
try:
    print(a[2])
    print(a[0] / a[1])

except IndexError:
    print('Такого элемента нет')
    print('Выполнение команд остановлено')
except ZeroDivisionError:
    print('Кто-то разделил число на 0')

# ошибки в цикле


def get_second_element(array):
    try:
        return array[4]
    except IndexError:
        print('### Элемент не найден, печатаю все элементы ###')
        for elem in array:
            print(f'### {elem} ###')
        return None

# ----------------------------------------------------------------------
# Срезы / Строки


a = [1, 3, 5, 5, 14]
a[1:5:2]  # [start:stop:step]

b = [1, 5, 8, 3, 4]
b[1:-1]  # правый конец не включается, поэтому отдаст список со второго по предпоследний элемент

b[-1:-2]  # может ничего не попасть
b[-2:-1]  # так отработает правильно
b[::2]  # вывести все элементы с шагом 2, с 0го
# каждый "минус первый" - это каждый первый, только в обратном порядке, т.е. просто развернет лист
b[::-1]
b[::-2]  # обратный порядок через один элемент

(1, 3, 9, 27, 36)[1:3]
c = (1, 3, 9, 27, 36)
print(c[1:3])
'hello world!'[6:]

# ----------------------------------------------------------------------
# Продвинутая работа со строками

't' in 'Anton'  # проверка символа
# поиск подстроки, регистр имеет значение
print('an' in 'Anton')
print('an' in 'Anton'.lower())
print('to' in 'Anton')

# .upper() lower()
# смена регистра
print('heLloo'.upper())  # верхний
print('heLloo'.lower())  # нижний

# islower() isupper()
# проверка в какой регистре строка
print('hello'.islower())
print('heLloo'.isupper())

# Поменять все найденные куски
# .replace(кого, на_что)
'Helluo wurld!'.replace('u', 'o')

'abra'.replace('mm', 'nn')  # ничего не нашел - вывел строку где искал
'Friends will be friends'.split()  # разбивает строку по пробелам
'my_test_data'.split('_')  # разбить по символу подчеркивания

# распаковка списка в 2 переменныx + разбить по пробелам
name, surname = input('name surname').split()

# Убрать мусорные пробелы вокруг строки (но не внутри!)
# убирает пробелы в начале и конце строки
'   После опознания текста много    пробелов     '.strip().split()

bad_string = '   После опознания текста много    пробелов     '
result = []
for word in (bad_string.strip()).split():
    result.append(word)
result

# ----------------------------------------------------------------------
# Аннотации типов

age: int = 5
print(age)
'''
Важно отметить, что аннотации типов никоим образом не влияют 
на время выполнения программы. Эти подсказки игнорируются интерпретатором 
и используются исключительно для повышения удобочитаемости для других 
программистов и вас самих.
'''


def mystery_combine(a: str, b: str, times: int) -> str:
    '''
    К параметрам функции добавились `: str, : str и : int` , чтобы показать, 
    какого типа они должны быть. Это должно сделать код более понятным для 
    чтения и лучше раскрыть его предназначение.
    '''
    return (a + b) * times


# ----------------------------------------------------------------------
# виртуальные окружения

# фиксация версий пакетов в файле: requirements.txt
pandas==1.4.0
pandas<1.4
numpy

# запуск установки из requirements.txt


pip install -r requirements.txt
# или 
pip install -U -r requirements.txt #чтобы pip поставил строго те версии pandas, которые вы указали

# создать окружение
python -m venv имя_окружения
python3 -m venv venv # linux

.\имя_окружения\Scripts\activate #Windows

# активация окружение командой(Linux и MacOS)
source имя_окружения/bin/activate
source venv/bin/activate


# Чтобы выйти из виртуального окружение нужно ввести команду
deactivate


# открыть notebook после активации окружения из этого окружения
python3 -m jupyter notebook
